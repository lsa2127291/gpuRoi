import type { MeshColor, MeshData, Segment3D, SliceBitmapOptions, Vec3 } from '@/types';
import type { BatchMeshSlicer } from './batch-slicer-interface';
export declare class BatchGPUSlicer implements BatchMeshSlicer {
    readonly backend: "gpu";
    private readonly device;
    private readonly canvasFormat;
    private slicePipeline;
    private drawArgsPipeline;
    private renderPipeline;
    private sliceBindGroupLayout;
    private renderBindGroupLayout;
    private renderUniformBuffer;
    private meshColorBuffer;
    private chunkGPUs;
    private meshCount;
    private outputCanvas;
    private outputContext;
    private msaaTexture;
    private msaaTextureSize;
    private readonly zeroCounter;
    private readonly zeroDrawArgs;
    private bitmapRenderRunning;
    private bitmapRequestSeq;
    private pendingBitmapRequest;
    private disposed;
    private sourceMeshes;
    private sourceColors;
    constructor(device: GPUDevice);
    initBatch(meshes: MeshData[], colors?: MeshColor[]): Promise<void>;
    updateMesh(meshIndex: number, mesh: MeshData): Promise<void>;
    sliceBatch(normal: Vec3, anchor: Vec3): Promise<Segment3D[][]>;
    sliceBatchFlat(normal: Vec3, anchor: Vec3): Promise<Segment3D[]>;
    sliceToBitmap(normal: Vec3, anchor: Vec3, options: SliceBitmapOptions): Promise<ImageBitmap>;
    dispose(): void;
    private runBitmapRenderLoop;
    private renderBitmapOnce;
    private resolveBitmapWaiters;
    private rejectBitmapWaiters;
    private cloneBitmap;
    private createPipelines;
    private createChunkGPU;
    private encodeSlicePass;
    private writeSliceUniform;
    private writeRenderUniform;
    private getActiveChunks;
    private dispatchAndReadCounter;
    private readbackSegments;
    private ensureOutputContext;
    private ensureMsaaTexture;
    private captureBitmap;
    private disposeChunks;
}
//# sourceMappingURL=batch-gpu-slicer.d.ts.map