# 笔刷功能 — 实现计划

## 1. 需求回顾

在当前视图上选定一个 `activeMesh`，通过笔刷对其进行布尔修改：

| 阶段 | 触发 | 行为 | 性能目标 |
|------|------|------|----------|
| 预览 | `mousemove` | 实时显示笔刷轨迹与 activeMesh 切面的布尔运算预览 | < 30ms |
| 提交 | `mouseup` | 将布尔结果写入 mesh 数据，刷新其他视图 | < 500ms |

笔刷精度 0.1mm，最大半径 50mm。

---

## 2. 一致性设计原则

预览和提交必须共享同一个几何真相源，否则用户看到的预览与最终结果会有偏差。

核心策略：**统一 2D 线段布尔引擎**

```
                    ┌──────────────────────────┐
                    │  Segment Boolean Engine   │
                    │  (2D 线段 × 多边形布尔)    │
                    └────────┬─────────────────┘
                             │
              ┌──────────────┼──────────────────┐
              ▼              ▼                   ▼
         预览渲染         提交：当前视图         提交：其他视图
     (直接绘制结果线段)   (结果线段 → 回写 mesh)  (重新 slice mesh)
```

- 预览和提交对当前视图使用完全相同的布尔运算函数，输入相同、输出相同
- 提交阶段额外做一步：将 2D 布尔结果反映到 3D mesh 数据上
- 其他视图通过重新 slice 更新后的 mesh 来刷新，天然一致

### 为什么不在预览阶段直接做 3D mesh boolean？

3D mesh boolean（三角形裁剪 + 重三角化）在大 mesh 上耗时 50-200ms，无法满足 30ms 的预览帧预算。
而 2D 线段布尔运算只处理当前切面的线段（通常几百到几千条），耗时 < 5ms。

---

## 3. 核心概念模型

```
┌──────────────────────────────────────────────────────────────────┐
│                         BrushSession                             │
│                                                                  │
│  activeMesh ──► 当前正在编辑的 MeshData                           │
│  brushStroke ──► 本次 mousedown→mouseup 的 2D 轨迹点集            │
│  plane ──────► 当前视图的切面 (normal + anchor)                    │
│  radius ─────► 笔刷半径 (mm)                                      │
│  mode ───────► 'add' | 'subtract'                                │
│                                                                  │
│  mousemove → computeBoolean() → 渲染结果线段 (预览)               │
│  mouseup   → computeBoolean() → 同一结果 → 回写 mesh + 刷新视图   │
│                                                                  │
│  ★ 预览和提交调用同一个 computeBoolean()，保证一致性               │
└──────────────────────────────────────────────────────────────────┘
```

---

## 4. 数据流设计

### 4.1 统一布尔运算 (预览 & 提交共用)

```
输入:
  activeSegments2D(mm) ── activeMesh 在当前切面的线段（local-mm，缓存）
  brushPolygon2D(mm) ──── 笔刷轨迹膨胀后的闭合多边形（local-mm）
  mode ───────────── 'add' | 'subtract'

         ┌─────────────────────────────────┐
         │    segmentBooleanWithPolygon()   │
         │                                  │
         │  对每条线段做多边形裁剪:          │
         │  subtract → 保留多边形外部分      │
         │  add → 轮廓区域并集后线段化       │
         └──────────────┬──────────────────┘
                        │
                        ▼
输出: resultSegments2D(mm) ── 布尔运算后的 2D 线段集合（local-mm）
```

这个函数是纯函数，无副作用，预览和提交都调用它。

坐标规范（执行约束）：
- 布尔链路统一使用 local-mm：`activeSegments2D` / `brushPolygon2D` / `resultSegments2D`
- 仅在渲染层做 mm ↔ canvas px 转换；布尔层禁止直接使用 canvas 坐标

### 4.2 渲染分层策略 — 全视图双 Bitmap（active / background）

仅在当前视图把 activeMesh 画成 Canvas 2D 线段，会引入三个问题：
1. `mousemove` 预览与 `mouseup` 后 GPU bitmap 风格不一致（线宽/端点/抗锯齿差异）。
2. activeMesh 数据量大时，切面变化用 segments 重绘比 bitmap 慢，易卡顿。
3. activeMesh 在多视图共享，单视图特化渲染不利于全局一致性。

#### 方案：每个视图长期维护两张 GPU bitmap

每个视图常驻缓存：
- `bgBitmap`：仅非 activeMesh
- `activeBitmap`：仅 activeMesh

统一合成：
```
Layer 0: drawImage(bgBitmap)
Layer 1: drawImage(activeBitmap)
Layer 2: drawBrushUI(cursor, highlight)   // 仅交互视图开启
```

`segmentBooleanWithPolygon()` 继续作为几何真相源，但 `segments` 只用于布尔计算和一致性验证，
不再承担长期显示职责。

##### 生成时机

`bgBitmap` / `activeBitmap` 生命周期跟随 `(activeMeshIndex, viewCamera, anchor, meshVersion)`：

```
initBatch 完成                 → 各视图同步生成首帧 bg + active
activeMesh 切换                → 各视图同步重建 bg + active
视图切换 / anchor 变化 / resize → 当前视图重建 bg + active
操作期间                      → 锁定 anchor，禁止滚动，沿用缓存
activeMesh 被提交修改          → 各视图仅重建 activeBitmap
非 activeMesh 被外部修改       → 各视图重建 bgBitmap（activeBitmap 保持）
```

##### active / background 过滤实现

不再使用“改 `meshColorBuffer` 再恢复”的方式，而是引入过滤接口：

```typescript
sliceToBitmapFiltered(normal, anchor, options, {
  mode: 'include' | 'exclude' | 'all',
  targetMeshIndex?: number, // include/exclude 时必填
})
```

过滤在 shader 的 mesh 级分支中完成，避免全局颜色状态改写，天然支持多视图并发调用。
`sliceToSplitBitmaps(activeMeshIndex)` 定义为单请求双输出（同一 request 生命周期内同时产出 `bgBitmap + activeBitmap`），
不能通过连续两次 filtered 调用拼装，避免 latest-wins 队列语义导致结果配对错误。

##### 缓存失效条件

| 事件 | bgBitmap 失效 | activeBitmap 失效 | 处理 |
|------|:---:|:---:|------|
| initBatch 完成 | ✓ | ✓ | 同步生成首帧 |
| activeMesh 切换 | ✓ | ✓ | 同步重建 |
| 视图切换 | ✓ | ✓ | 当前视图同步重建 |
| anchor 变化（非操作期间） | ✓ | ✓ | 当前视图同步重建 |
| 操作期间 anchor 变化 | — | — | 操作期间禁止滚动 |
| activeMesh 被操作修改 | ✗ | ✓ | 各视图仅重建 active |
| 非 activeMesh 被外部修改 | ✓ | ✗ | 各视图仅重建 bg |
| 窗口 resize | ✓ | ✓ | 当前视图同步重建 |

##### 内存开销

每视图两张 bitmap：512×512×4×2 ≈ 2MB，3 个 MPR 视图约 6MB，可接受。

##### 需要修改的文件

| 文件 | 改动 |
|------|------|
| `src/core/slicer-batch-bitmap.wgsl` | 增加 mesh filter 参数与分支（include/exclude/all） |
| `src/core/batch-gpu-slicer.ts` | 新增 `sliceToBitmapFiltered()` / `sliceToSplitBitmaps()` |
| `src/core/batch-slicer-interface.ts` | 接口新增过滤切面方法 |

##### 验证方式

1. `sliceToBitmapFiltered(include:active)` 仅包含 activeMesh（像素级验证）
2. `sliceToBitmapFiltered(exclude:active)` 不包含 activeMesh（像素级验证）
3. `bgBitmap + activeBitmap ≈ 全量 sliceToBitmap`（视觉对比）
4. 操作期间 `mousemove` 合成渲染 < 30ms

### 4.3 预览阶段 (mousemove, < 30ms)

```
[交互前预准备（由视图状态变化触发）]
  sliceToSplitBitmaps(activeMeshIdx) → bgBitmap + activeBitmap (缓存)
  sliceBatch(normal, anchor) → 过滤 activeMesh 段 → projectPointTo2D(local-mm) → activeSegments2D(mm) (缓存)

[mousedown]
  仅初始化 stroke，会话直接读取已缓存 bgBitmap / activeBitmap / activeSegments2D
  （若缓存失效则先重建缓存，再进入 drawing）

[每帧 mousemove]
  鼠标坐标 (px)
    │
    ▼
  canvasToLocalMm() → 切面局部 mm 坐标
    │
    ▼
  累积 brushStroke → strokeToPolygon() → brushPolygon2D
    │
    ▼
  segmentBooleanWithPolygon(cachedActiveSegments2D, brushPolygon2D, mode) → resultSegments2D
    │
    ▼
  rasterizeSegmentsToBitmap(resultSegments2D) → activePreviewBitmap
    │
    ▼
  合成渲染:
    Layer 0: drawImage(bgBitmap)              ← 缓存，不重算
    Layer 1: drawImage(activePreviewBitmap)   ← 每帧重绘（GPU 风格一致）
    Layer 2: drawBrushUI(cursor, highlight)    ← 每帧重绘
```

### 4.4 提交阶段 (mouseup, < 500ms)

```
最终 brushPolygon2D (与最后一帧预览完全相同)
  │
  ├──► segmentBooleanWithPolygon() → resultSegments2D
  │    │
  │    ▼
  │    当前视图立即固化 activePreviewBitmap 为 activeBitmap（无闪烁）
  │
  ├──► brushPolygon2D → 反投影到 3D → brushPolygon3D
  │    │
  │    ▼
  │    applyBrushToMesh(activeMesh, brushPolygon3D, normal, anchor, mode)
  │    │
  │    ▼
  │    newMesh → updateMesh(meshIndex, newMesh)
  │
  └──► 各视图: 仅重建 activeBitmap（filtered include:activeMesh）
```

提交后当前视图的过渡：
1. mouseup 瞬间：直接显示 `bgBitmap + activePreviewBitmap`（与最后一帧预览完全一致）
2. 异步完成 `applyBrushToMesh` + `updateMesh` 后：仅替换 `activeBitmap`
3. 保持分层模式，不做当前视图全量 `sliceToBitmap` 回刷

### 4.5 一致性保证链

```
预览帧 N:  segmentBoolean(segments, polygon_N) → preview_N
提交:      segmentBoolean(segments, polygon_N) → commit_result  (= preview_N ✓)
当前视图:  commit_activeBitmap 直接沿用最后一帧预览             (= preview_N ✓)
其他视图:  updateMesh(newMesh) 后 sliceToBitmapFiltered(include:active) → activeBitmap 刷新 (几何一致 ✓)
```

唯一的"不一致窗口"：其他视图在 slice 完成前显示旧数据，但这是异步刷新的固有延迟，不是几何偏差。

### 4.6 一致性的残余风险与对策

即使预览和提交共用 `segmentBooleanWithPolygon()`，仍有一个潜在偏差来源：

提交阶段的 `applyBrushToMesh()` 修改了 3D mesh 后，其他视图重新 slice 产出的线段，
与当前视图通过 2D 布尔运算得到的线段，在几何上是否严格等价？

答案是：在当前切面上严格等价，在其他切面上由 mesh 拓扑决定。

具体分析：
- 当前切面：`applyBrushToMesh` 的职责是让 mesh 在当前切面上的 slice 结果 = `resultSegments2D`。
  这是它的正确性约束，实现时必须以此为验证标准。
- 其他切面：由修改后的 mesh 几何决定，没有"预览"参照，天然一致。

因此关键在于 `applyBrushToMesh` 的实现质量。测试策略：
```
applyBrushToMesh(mesh, polygon3D, normal, anchor, mode) → newMesh
sliceMesh(newMesh, normal, anchor) → newSegments3D
project(newSegments3D) → newSegments2D

assert: newSegments2D ≈ segmentBooleanWithPolygon(originalSegments2D, polygon2D, mode)
                         (容差 = precision / 2 = 0.05mm)
```

---

## 5. 模块拆分

### 5.1 新增文件

```
src/
├── core/
│   ├── brush/
│   │   ├── brush-types.ts            # 笔刷相关类型定义
│   │   ├── brush-stroke.ts           # 轨迹采集与简化
│   │   ├── brush-polygon.ts          # 轨迹 → 2D 闭合多边形 (Minkowski 膨胀)
│   │   ├── segment-boolean.ts        # ★ 统一 2D 线段布尔引擎 (预览+提交共用)
│   │   ├── mesh-boolean.ts           # 3D mesh 修改 (提交用, 以 segment-boolean 结果为约束)
│   │   ├── brush-session.ts          # 会话管理 (状态机)
│   └── __tests__/
│       ├── brush-stroke.test.ts
│       ├── brush-polygon.test.ts
│       ├── segment-boolean.test.ts
│       ├── mesh-boolean.test.ts
│       └── consistency.test.ts       # ★ 预览-提交一致性验证
├── renderer/
│   ├── brush-overlay-renderer.ts     # 笔刷预览叠加层渲染
│   └── multi-view-manager.ts         # 多视图协调
```

### 5.2 修改文件

| 文件 | 改动 |
|------|------|
| `src/core/brush/brush-types.ts` | 定义 `BrushMode`、`BrushConfig`、`PlaneSegment2D` 等笔刷域类型 |
| `src/types/index.ts` | 仅在需要跨模块复用时导出公共类型，不承载 brush 域细节 |
| `src/core/batch-slicer-interface.ts` | 新增 `updateMesh`、`sliceToBitmapFiltered`、`sliceToSplitBitmaps` 方法签名 |
| `src/core/batch-gpu-slicer.ts` | 实现 `updateMesh`、`sliceToBitmapFiltered`、`sliceToSplitBitmaps`（mesh 过滤切面） |
| `src/core/slicer-batch-bitmap.wgsl` | 增加 mesh filter 参数与 include/exclude 分支 |
| `src/renderer/slice-renderer.ts` | 集成 `BrushOverlayRenderer` |
| `src/demo/main.ts` | 接入笔刷交互 demo |

---

## 6. 详细设计

### 6.1 `brush-types.ts` — 类型定义

```typescript
export type BrushMode = 'add' | 'subtract'

export interface BrushConfig {
  radius: number        // mm, 范围 [0.1, 50]
  precision: number     // mm, 默认 0.1
  mode: BrushMode
}

export interface BrushPoint {
  x: number  // mm, 切面局部坐标
  y: number  // mm, 切面局部坐标
  timestamp: number
}

export interface BrushSessionState {
  status: 'idle' | 'drawing' | 'committing'
  activeMeshIndex: number
  config: BrushConfig
  stroke: BrushPoint[]
  previewPolygon: [number, number][] | null
}

// 布尔计算专用：local-mm 坐标，不复用渲染层 Segment2D(canvas px)
export interface PlaneSegment2D {
  start: [number, number]
  end: [number, number]
}
```

### 6.2 `brush-stroke.ts` — 轨迹采集与简化

职责：
- 将 canvas 像素坐标转换为切面局部 mm 坐标（逆 `toCanvasCoord` + 逆 `projectPointTo2D`）
- 采集 mousemove 点，按最小间距 `precision` (0.1mm) 去重
- Douglas-Peucker 简化，控制点数在合理范围内

```typescript
export function canvasToLocalMm(
  canvasPt: [number, number],
  canvasWidth: number,
  canvasHeight: number,
  scale: number,
): [number, number]

export function simplifyStroke(
  points: BrushPoint[],
  tolerance: number,
): BrushPoint[]
```

### 6.3 `brush-polygon.ts` — 轨迹膨胀为闭合多边形

将笔刷轨迹（polyline）按半径 `r` 做 Minkowski sum 膨胀，生成闭合多边形：

- 单点 → 圆形（正 N 边形近似，N 由精度决定）
- 多点 → 沿轨迹的等距偏移轮廓 + 两端半圆帽

```typescript
export function strokeToPolygon(
  stroke: BrushPoint[],
  radius: number,
  precision: number,
): [number, number][]
```

实现策略：
- 对每段线段做左右偏移 `±radius`
- 端点处用圆弧插值（步长由 precision 控制弧段数）
- 合并为单一闭合多边形
- 时间复杂度 O(N)，N 为轨迹点数

### 6.4 `segment-boolean.ts` — ★ 统一 2D 线段布尔引擎

这是保证预览-提交一致性的核心模块。预览和提交都调用同一个纯函数。

```typescript
/**
 * 对 2D 线段集合与闭合多边形做布尔运算
 *
 * subtract: 裁剪掉线段落在多边形内部的部分
 * add:      原轮廓区域与 brushPolygon 做并集后再线段化
 *
 * 纯函数，无副作用
 */
export function segmentBooleanWithPolygon(
  segments: PlaneSegment2D[],
  polygon: [number, number][],
  mode: BrushMode,
): PlaneSegment2D[]
```

算法（subtract 模式）：
```
对每条线段 seg:
  1. 计算 seg 与 polygon 各边的交点 → 得到参数 t 列表
  2. 按 t 排序，将 seg 分割为子段
  3. 对每个子段中点做 point-in-polygon 测试
  4. 保留中点在多边形外部的子段
```

算法（add 模式）：
```
  1. 对输入 segments 做容差连通，重建闭合轮廓（可能多环，含内孔）
  2. 轮廓区域与 brushPolygon 做 2D 区域并集
  3. 将并集结果边界线段化，输出 PlaneSegment2D[]
  4. 若闭合轮廓重建失败，降级为“原线段 + brushPolygon 边界线段”并记录诊断日志
```

性能约束：
- subtract 路径保持 O(S × E)（S=线段数，E=多边形边数），目标 < 5ms（S=2000, E=200）
- add 路径允许高于 subtract，但预览总帧耗时仍需满足 < 30ms

### 6.5 `mesh-boolean.ts` — 3D Mesh 修改（提交用）

提交阶段需要将 2D 布尔结果反映到 3D mesh 数据上。

核心约束：修改后的 mesh 在当前切面上 slice 的结果，必须与 `segmentBooleanWithPolygon` 的输出一致。

```typescript
export function applyBrushToMesh(
  mesh: MeshData,
  brushPolygon3D: Vec3[],   // 2D polygon 反投影到切面上的 3D 坐标
  normal: Vec3,
  anchor: Vec3,
  precision: number,        // 拉伸厚度 = precision
  mode: BrushMode,
): MeshData
```

算法流程：
```
1. 筛选与切面相交的三角形 (planeIntersectsBoundingBox 预剔除)
2. brushPolygon3D 沿 normal 拉伸 ±(precision/2) → brushPrism (薄片棱柱)
3. 对每个相交三角形:
   a. 投影到切面 2D 坐标系
   b. 用 brushPolygon2D 裁剪三角形 (Sutherland-Hodgman)
   c. subtract: 保留多边形外部分 → 重三角化 (ear-clipping)
   d. add: 保留原三角形 + 在多边形区域生成新三角形
4. 未相交的三角形原样保留
5. 合并所有三角形 → 新的 vertices + indices
```

### 6.6 `brush-session.ts` — 会话状态机

```
         mousedown              mousemove              mouseup
  idle ──────────► drawing ──────────► drawing ──────────► committing ──► idle
                     │                    │                    │
                     ▼                    ▼                    ▼
               初始化 stroke      segmentBoolean()      segmentBoolean() (同一结果)
               读取缓存层数据      + rasterize 预览       + applyBrushToMesh()
               (不做重切面)        activeBitmap          + 刷新各视图 active 层
```

```typescript
export class BrushSession {
  private cachedActiveSegments: PlaneSegment2D[] | null = null
  private lastBooleanResult: PlaneSegment2D[] | null = null
  private lastPreviewBitmap: ImageBitmap | null = null

  constructor(
    activeMeshIndex: number,
    config: BrushConfig,
    plane: { normal: Vec3; anchor: Vec3 },
    basis: LocalBasis,
    canvasSize: { width: number; height: number },
    scale: number,
  )

  onMouseDown(canvasPt: [number, number]): void
  onMouseMove(canvasPt: [number, number]): BrushPreviewResult | null
  onMouseUp(): BrushCommitRequest | null
}

export interface BrushPreviewResult {
  resultSegments: PlaneSegment2D[]       // local-mm 布尔结果（几何真相源）
  activePreviewBitmap: ImageBitmap       // GPU 栅格化后的 active 预览层
  brushPolygonCanvas: [number, number][] // canvas 坐标的笔刷多边形 (用于高亮)
}

export interface BrushCommitRequest {
  meshIndex: number
  resultSegments: PlaneSegment2D[]       // ★ 与最后一帧预览完全相同（local-mm）
  committedActiveBitmap: ImageBitmap     // mouseup 瞬间直接显示，无需全量回刷
  brushPolygon3D: Vec3[]
  normal: Vec3
  anchor: Vec3
  precision: number
  mode: BrushMode
}
```

### 6.7 `BrushOverlayRenderer` — 预览渲染

```typescript
export class BrushOverlayRenderer {
  constructor(canvas: HTMLCanvasElement)

  // 设置背景层（非 activeMesh）
  setBackgroundBitmap(bitmap: ImageBitmap): void
  // 设置 active 层（activeMesh）
  setActiveBitmap(bitmap: ImageBitmap): void

  // 绘制静态帧：bg + active
  renderStatic(): void

  renderCursor(center: [number, number], radiusPx: number): void

  // 合成渲染：bgBitmap + activePreviewBitmap + 笔刷 UI
  renderPreview(preview: BrushPreviewResult, mode: BrushMode): void

  // 提交瞬间固化 active 层（沿用最后一帧预览）
  renderCommittedActive(bitmap: ImageBitmap): void

  clear(): void
}
```

渲染层次（从下到上）：
1. Layer 0: 背景 bitmap — `sliceToBitmapFiltered(exclude:activeMesh)` 的缓存结果
2. Layer 1: active bitmap / activePreviewBitmap — activeMesh 独立位图层
3. Layer 2: 笔刷 UI — 区域半透明填充 (add=绿色, subtract=红色) + 光标圆圈

### 6.8 `BatchMeshSlicer` 接口扩展

在 `batch-slicer-interface.ts` 新增：

```typescript
export type SliceFilterMode = 'all' | 'include' | 'exclude'

export interface SliceMeshFilter {
  mode: SliceFilterMode
  targetMeshIndex?: number // include/exclude 时必填
}

export interface BatchMeshSlicer {
  // ... 已有方法

  /** 增量更新单个 mesh（避免全量 initBatch） */
  updateMesh(meshIndex: number, newMesh: MeshData): Promise<void>

  /** 带 mesh 过滤条件的位图切面（include/exclude/all） */
  sliceToBitmapFiltered(
    normal: Vec3,
    anchor: Vec3,
    options: SliceBitmapOptions,
    filter: SliceMeshFilter,
  ): Promise<ImageBitmap>

  /** 便捷方法：一次请求获取 bg + active 两层位图 */
  sliceToSplitBitmaps(
    normal: Vec3,
    anchor: Vec3,
    options: SliceBitmapOptions,
    activeMeshIndex: number,
  ): Promise<{ bgBitmap: ImageBitmap; activeBitmap: ImageBitmap }>
}
```

`sliceToBitmapFiltered` 实现方式：
1. 在 compute 阶段确定 segment 所属 meshIndex 后执行 filter 判断
2. `mode='include'`：仅保留 `targetMeshIndex` 的 segment
3. `mode='exclude'`：丢弃 `targetMeshIndex` 的 segment
4. `mode='all'`：与现有 `sliceToBitmap` 一致

不再改写 `meshColorBuffer`，避免多视图并发时的全局状态竞争。
`sliceToSplitBitmaps` 必须作为单请求双输出接口实现，保证 `bgBitmap` 与 `activeBitmap` 来自同一时刻同一请求。

在 `BatchGPUSlicer` 中实现：
- 定位 mesh 所在的 chunk
- 默认重建该 mesh 所在 chunk（重排 triOffset / triCount / bbox）
- 若 chunk 重建后触发布局级联成本过高，则回退全量 `initBatch`
- 更新 `meshInfos` 中的 `triOffset` / `triCount` / `bbox`

### 6.9 `multi-view-manager.ts` — 多视图协调

```typescript
export class MultiViewManager {
  registerView(id: string, view: ViewInstance): void
  unregisterView(id: string): void
  refreshOtherViews(currentViewId: string): Promise<void>
  refreshAllViews(): Promise<void>
}

export interface ViewInstance {
  id: string
  camera: CameraData
  anchor: Vec3
  canvas: HTMLCanvasElement
  render(): Promise<void>
}
```

---

## 7. 性能分析

### 7.1 分层缓存重建 (非 mousemove 热路径)

| 步骤 | 预估耗时 | 说明 |
|------|----------|------|
| sliceToSplitBitmaps(activeMesh) | < 70ms | GPU 生成 bgBitmap + activeBitmap |
| sliceBatch → filter active → projectPointTo2D | < 30ms | 缓存 activeSegments2D(local-mm)（布尔计算输入） |
| 总计 | < 100ms | 在 active 切换/视图变化/anchor 变化时触发 |

`mousedown` 开销目标：仅初始化轨迹与状态切换，< 0.2ms。

### 7.2 预览阶段 (每帧 mousemove, < 30ms 目标)

| 步骤 | 预估耗时 | 说明 |
|------|----------|------|
| 坐标转换 | < 0.1ms | 纯算术 |
| 轨迹简化 | < 0.5ms | Douglas-Peucker, 增量式 |
| 多边形膨胀 | < 1ms | O(N) 偏移算法 |
| segmentBooleanWithPolygon | < 5ms | O(S×E), S=2000, E=200 |
| rasterizeSegmentsToBitmap | < 8ms | GPU 生成 activePreviewBitmap |
| Canvas 合成渲染 | < 3ms | drawImage(bgBitmap) + drawImage(activePreviewBitmap) + drawBrushUI |
| 总计 | < 18ms | 满足 30ms 目标 |

关键优化：
- 缓存在 active 切换/视图变化阶段预生成，mousedown 不触发重切面
- 预览只替换 Layer 1（activePreviewBitmap），背景层完全复用
- `segmentBooleanWithPolygon` 仍是纯函数，可做增量优化（只处理新增笔刷区域影响的线段）

### 7.3 提交阶段 (mouseup, < 500ms 目标)

| 步骤 | 预估耗时 | 说明 |
|------|----------|------|
| segmentBooleanWithPolygon | < 5ms | 与预览同一调用 |
| 当前视图固化 commit_activeBitmap | < 1ms | 直接沿用最后一帧 activePreviewBitmap |
| 2D→3D 反投影 | < 1ms | 纯算术 |
| applyBrushToMesh | < 100ms | 局部三角形裁剪 + 重三角化 |
| GPU buffer 增量更新 | < 20ms | updateMesh 重建所属 chunk（必要时回退全量 initBatch） |
| 各视图刷新 activeBitmap(filtered include) | < 120ms | 并行刷新 active 层 |
| 非 active 变更触发 bgBitmap 刷新 | 0ms（常见） / < 120ms（少见） | 仅在非 active mesh 被改动时触发 |
| 总计 | < 250ms（常见） | 满足 500ms 目标 |

### 7.4 内存预算

- 背景 + active 双 bitmap：512×512 RGBA × 2 ≈ 2MB/视图（3 视图约 6MB）
- activePreview 临时 bitmap：≈ 1MB（仅当前交互视图）
- 笔刷轨迹点：最大 ~5000 点 × 24 bytes ≈ 120KB
- 膨胀多边形：最大 ~10000 顶点 × 16 bytes ≈ 160KB
- 缓存 activeSegments2D：~2000 条 × 32 bytes ≈ 64KB
- 临时三角形缓冲：< 1MB

---

## 8. 实现阶段

### Phase 1: 基础设施 + 统一布尔引擎 (3 天)

1. 定义 `brush-types.ts` 类型
2. 实现 `brush-stroke.ts`（坐标转换 + 轨迹采集 + 简化）
3. 实现 `brush-polygon.ts`（轨迹膨胀）
4. ★ 实现 `segment-boolean.ts`（统一 2D 线段布尔引擎）
5. 单元测试覆盖，特别是 segment-boolean 的边界情况

### Phase 2: 渲染分层 + 预览 (3 天)

1. `slicer-batch-bitmap.wgsl` 增加 mesh filter；实现 `sliceToBitmapFiltered()` 和 `sliceToSplitBitmaps()`
2. 实现 `BrushOverlayRenderer`（三层合成：bgBitmap + activeBitmap/activePreviewBitmap + brushUI）
3. 实现 `BrushSession` 状态机（mousedown 仅初始化轨迹，读取预生成缓存）
4. 集成到 demo 页面，验证预览效果
5. 确认 mousemove 帧耗时 < 30ms

### Phase 3: 3D Mesh 修改 + 一致性验证 (4-5 天)

1. 实现 `mesh-boolean.ts`（局部三角形裁剪 + 重三角化）
2. ★ 编写 `consistency.test.ts`：验证 slice(newMesh) ≈ segmentBoolean(oldSegments, polygon)
3. 迭代修复直到一致性测试通过（容差 0.05mm）

### Phase 4: 增量更新与多视图 (2-3 天)

1. 实现 `BatchGPUSlicer.updateMesh`
2. 实现 `MultiViewManager`
3. 提交后刷新各视图 active 层（必要时刷新 bg 层）
4. 端到端性能验证 < 500ms

### Phase 5: 集成与打磨 (2 天)

1. Demo 页面完整集成
2. 边界情况处理（空 mesh、笔刷超出视图、极小/极大半径）
3. 性能 benchmark 扩展

---

## 9. 风险与备选方案

| 风险 | 影响 | 备选方案 |
|------|------|----------|
| `applyBrushToMesh` 与 `segmentBoolean` 结果不一致 | 预览-提交视觉跳变 | consistency.test.ts 强制验证；必要时用 segmentBoolean 结果反向约束 mesh 修改 |
| 3D 布尔运算退化（共面、自交） | 提交失败或 mesh 损坏 | 引入 robust predicates；退化为体素化 |
| 提交阶段超 500ms（大 mesh） | 用户体验卡顿 | 将 applyBrushToMesh 移至 Web Worker |
| 双 bitmap 缓存失效判断错误 | 视图显示旧层或错层 | 统一 `meshVersion + activeMeshIndex + camera + anchor` 版本键；每次提交后断言重建路径 |
| `sliceToSplitBitmaps` 由两次 filtered 调用拼装 | bg/active 来自不同请求时刻，出现错配闪烁 | 强制单请求双输出；对输出打同一 requestId 断言 |
| add 模式轮廓重建失败（开链/自交） | add 结果不稳定 | 降级为“原线段 + brushPolygon 边界线段”，并记录告警用于后续修复 |
| 重三角化产生退化三角形 | 后续切面出错 | constrained Delaunay 替代 ear-clipping |
| 多次笔刷累积导致 mesh 膨胀 | 内存/性能下降 | 定期 mesh 简化（decimation） |

---

## 10. 测试策略

| 层级 | 覆盖内容 | 工具 |
|------|----------|------|
| 单元测试 | 坐标转换、轨迹简化、多边形膨胀、segment-boolean | Vitest |
| ★ 一致性测试 | `slice(applyBrush(mesh)) ≈ segmentBoolean(slice(mesh))` | Vitest |
| 集成测试 | BrushSession 完整流程 | Vitest |
| 性能测试 | mousemove < 30ms, commit < 500ms | bench 页面 |

核心测试用例：
- 立方体 + 圆形笔刷 subtract → 切面出现缺口，预览=提交
- 立方体 + 线性笔刷 add → 切面出现凸起，预览=提交
- 边界：笔刷完全在 mesh 外 → mesh 不变，预览=原始切面
- 边界：笔刷完全覆盖切面 → subtract 后切面为空
- ★ 一致性：对 N 种随机笔刷轨迹，验证 slice(newMesh) 与 segmentBoolean 结果的最大偏差 < 0.05mm
