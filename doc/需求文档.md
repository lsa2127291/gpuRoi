这份需求文档基于你提供的 3D Mesh 数据、相机定义和锚点逻辑，旨在描述一个 **3D 网格切面计算与 2D 渲染模块**。

---

# 需求文档：3D Mesh 切面实时渲染模块 (MPR Slice Renderer)

## 1. 项目概述
本项目旨在开发一个能够处理 3D 网格（Mesh）数据的图形模块。该模块根据输入的“相机视角（定义切面法线）”和“锚点（定义切面位置）”，实时计算 Mesh 与平面的相交轮廓（截面），并将计算结果转换到 2D 坐标系中，最终绘制在 HTML5 Canvas 上。

主要应用场景类似于医学影像中的 MPR（多平面重建）视图，或者 CAD 软件中的剖面查看。

## 2. 数据定义与输入规范

### 2.1 3D Mesh 数据
模块需支持以下格式的 Mesh 数据输入（参考 `TEST_CUBE` 示例）：
*   **Vertices (顶点):** `Float32Array`, 格式为 `[x, y, z, x, y, z, ...]`。
*   **Indices (索引):** `Uint32Array` 或 `Uint16Array`, 定义三角形连接关系 `[v0, v1, v2, ...]`。
*   **Normals (法线):** `Float32Array`, 顶点对应的法向量（本需求主要用于光照或辅助计算，核心切割算法主要依赖 Vertices 和 Indices）。
*   **校验:** 输入数据必须构成合法的三角网格。

### 2.2 相机/视图数据 (Camera/View Definition)
定义切割平面的方向和 2D 投影的坐标系。
*   **Structure:**
    ```javascript
    {
      viewPlaneNormal: [x, y, z], // 切割平面的法线向量 (Plane Normal)
      viewUp: [x, y, z]           // 定义平面“上方”的向量，用于确定 2D 投影的 Y 轴
    }
    ```
*   **预设视图 (MPR):**
    *   **Axial (轴状位):** Normal `[0, 0, -1]`, Up `[0, -1, 0]`
    *   **Sagittal (矢状位):** Normal `[-1, 0, 0]`, Up `[0, 0, 1]`
    *   **Coronal (冠状位):** Normal `[0, -1, 0]`, Up `[0, 0, 1]`

### 2.3 锚点数据 (Anchor Point)
定义切割平面在 3D 空间中的具体位置。
*   **格式:** `[x, y, z]` (例如 `[0, 0, 0]`)
*   **作用:** 切割平面必定经过此点。

## 3. 功能需求 (Functional Requirements)

### 3.1 核心算法：网格切割 (Mesh Slicing)
系统需实现一个数学计算模块，输入 Mesh、Plane(Normal, Point)，输出截面线段集合。

1.  **平面定义:** 根据 `Anchor` (点 $P_0$) 和 `viewPlaneNormal` (法线 $N$) 定义平面方程：
    $$N \cdot (P - P_0) = 0$$
2.  **遍历与相交检测:**
    *   遍历 Mesh 的每一个三角形（根据 Indices 获取三个顶点 $V_0, V_1, V_2$）。
    *   计算每个顶点到平面的有符号距离 (Signed Distance)。
    *   若三个顶点都在平面同一侧（距离符号相同），则丢弃该三角形。
    *   若顶点分布在平面两侧，则计算三角形边与平面的**交点**。通常一个被切割的三角形会产生两个交点，这两个交点构成一条**线段 (Segment)**。
3.  **输出数据:** 一个包含多条线段的数组，每条线段由两个 3D 坐标点组成：`[[Start3D, End3D], ...]`。

### 3.2 坐标转换 (3D to 2D Projection)
为了在 2D Canvas 上绘制，必须将切割得到的 3D 线段投影到切面的 2D 局部坐标系中。

1.  **构建局部坐标系 (Orthonormal Basis):**
    *   **Z轴 (Local Z):** `viewPlaneNormal` ($N$)
    *   **Y轴 (Local Y):** `viewUp` ($U$)。*注：需确保 $U$ 与 $N$ 垂直，若不垂直需进行正交化处理。*
    *   **X轴 (Local X):** CrossProduct($U$, $N$)。
2.  **投影计算:**
    *   对于每个交点 $P_{inter}$，计算其相对于 `Anchor` 的 2D 坐标 $(x', y')$：
        *   $x' = (P_{inter} - Anchor) \cdot \text{Local X}$
        *   $y' = (P_{inter} - Anchor) \cdot \text{Local Y}$
3.  **Canvas 坐标映射:**
    *   将物理尺寸（mm）映射到 Canvas 像素空间（需引入缩放比例 `scale` 和 Canvas 中心偏移 `offset`）。

### 3.3 渲染绘制 (Rendering)
使用 HTML5 Canvas 2D Context API 进行绘制。

*   **清空画布:** 每次数据更新前清空。
*   **绘制线段:** 遍历转换后的 2D 线段数组，使用 `beginPath()`, `moveTo()`, `lineTo()`, `stroke()` 绘制。
*   **样式配置:** 支持设置线条颜色（如红色）、线宽。

### 3.4 动态交互 (Interactivity)
模块需暴露 API 以支持动态更新：

*   `updateMesh(meshData)`: 替换几何体（低频操作）。
*   `updateCamera(cameraData)`: 切换视角（如从 Axial 切到 Sagittal）。
*   `updateAnchor(point)`: 移动切面位置（高频操作，如鼠标拖拽滚动）。
*   **响应式更新:** 当上述任意数据发生变化时，自动触发“重计算 -> 重投影 -> 重绘制”流程。

## 4. 技术实现建议 (Technical Specifications)

### 4.1 接口设计 (API Draft)

```typescript
interface MeshData {
  vertices: Float32Array;
  indices: Uint32Array;
  normals?: Float32Array;
}

interface CameraData {
  viewPlaneNormal: [number, number, number]; // 归一化向量
  viewUp: [number, number, number];          // 归一化向量
}

class SliceRenderer {
  constructor(canvas: HTMLCanvasElement);

  // 初始化或更新 Mesh
  public setMesh(data: MeshData): void;

  // 更新切割参数并触发重绘
  public updateSlice(camera: CameraData, anchor: [number, number, number]): void;

  // 设置渲染参数（可选）
  public setRenderStyle(color: string, width: number, scale: number): void;
}
```

### 4.2 性能优化要求
*   **避免垃圾回收 (GC):** 在切割算法中，尽量复用数组或对象池来存储交点数据，避免在 `requestAnimationFrame` 或高频 `updateAnchor` 中创建大量临时对象。
*   **TypedArray 优化:** 核心计算应直接操作 `Float32Array`，避免频繁转换为普通 JS Array。
*   **提前剔除:** 利用 Bounding Box (包围盒) 检测，如果平面完全在 Mesh 包围盒之外，直接跳过遍历。

## 5. 测试用例 (Test Scenario)

基于提供的 `TEST_CUBE` 数据进行验收测试：

**场景:**
*   **Mesh:** 边长 100mm 的立方体 (中心在 0,0,0，范围 -50 到 50)。
*   **Anchor:** `[0, 0, 0]`。

**预期结果:**
1.  **Axial View (Normal: [0,0,-1], Up: [0,-1,0]):**
    *   切割平面为 Z=0 平面。
    *   **逻辑输出:** 一个中心在原点的正方形线框，边长 100mm。
    *   **Canvas显示:** 正方形。
2.  **Sagittal View (Normal: [-1,0,0]):**
    *   切割平面为 X=0 平面。
    *   **Canvas显示:** 正方形。
3.  **偏移测试:**
    *   将 Anchor 改为 `[0, 0, 50]` (立方体顶部边缘)。
    *   **Canvas显示:** 依然是正方形（或者是点/极细的线，取决于浮点数精度处理，理想情况是此时刚好切到面）。
    *   将 Anchor 改为 `[0, 0, 60]`。
    *   **Canvas显示:** 空白（无相交）。

## 6. 交付物
1.  **源代码:** 包含核心切割算法类和 Canvas 渲染逻辑。
2.  **Demo 页面:** 集成上述示例数据，提供简单的 UI 按钮切换视角 (Axial/Sagittal/Coronal) 和 滑动条改变 Anchor 位置。
3.  **开发文档:** 说明 API 调用方式。
